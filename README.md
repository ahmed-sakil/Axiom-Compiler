<div align="center">

âš¡ A X I O M

High-Performance Stack-Based Compiler & Virtual Machine

Axiom is a custom programming language implementation featuring a hand-written recursive descent compiler and a lightweight stack-based virtual machine. It demonstrates core compiler design concepts without external dependencies.

Features â€¢ Architecture â€¢ Syntax â€¢ Internals

</div>

ğŸ— System Architecture

Axiom follows a classic three-stage compiler pipeline. The diagram below represents the flow of data from source code to execution.

graph LR
    A[Source Code] -->|Lexer| B(Tokens)
    B -->|Parser| C{Abstract Syntax Tree}
    C -->|Code Gen| D[Bytecode Instructions]
    D -->|Virtual Machine| E[Stack Execution]
    E -->|Output| F[Console/IDE]
    
    style A fill:#f9f,stroke:#333,stroke-width:2px
    style D fill:#bbf,stroke:#333,stroke-width:2px
    style E fill:#bfb,stroke:#333,stroke-width:2px


ğŸš€ Key Features

âš¡ Stack-Based VM: A custom CPU simulation that uses a stack for arithmetic and logic, similar to the JVM or WebAssembly.

ğŸ§  Recursive Descent Parser: A top-down parser that automatically handles operator precedence (PEMDAS) and nested parentheses.

ğŸ’¾ Symbol Table Memory: Dynamic memory management allowing for variable declaration, storage, and retrieval.

ğŸ›¡ï¸ Robust Error Handling: The compiler detects syntax errors (like missing semicolons) and runtime errors (like division by zero).

ğŸ–¥ï¸ Hybrid Tooling: Built with a high-performance C++ backend for execution and a Python frontend for the IDE.

ğŸ“ Axiom Syntax Guide

Axiom is designed to be C-like but simplified for educational clarity.

1. Variables & Math

// Define variables using 'set'
set width = 10;
set height = 25;

// Axiom handles complex math order-of-operations automatically
set area = (width + height) * 2; 

// Division and Subtraction support
set result = area / 5 - 2;


2. Output

// Print results to the console
print result;


3. Comments

// Lines starting with double-slashes are ignored by the Lexer
set x = 100; // Inline comments work too!


âš™ Under the Hood: Implementation

The core engine is built in C++ and consists of three distinct components.

1. The Lexer (Tokenizer)

The Lexer scans the raw text string and groups characters into Tokens. It handles whitespace elimination and comment stripping.

Input: set x = 10;

Output: [TOKEN_SET], [TOKEN_ID, "x"], [TOKEN_ASSIGN], [TOKEN_INT, 10], [TOKEN_SEMI]

2. The Parser (Code Generator)

The Parser uses a Recursive Descent strategy. It calls specific functions based on priority:

parseFactor(): Handles numbers and parentheses (Highest Priority).

parseTerm(): Handles * and /.

parseExpression(): Handles + and - (Lowest Priority).

As it traverses the logic, it emits Bytecode integers into a vector.

3. The Virtual Machine (Backend)

The VM executes the generated bytecode using a Fetch-Decode-Execute cycle. It operates entirely on a data stack and a global memory array.

Supported OpCodes:

Hex

Mnemonic

Description

Stack Impact

0x01

PUSH

Push integer to stack

[ ] -> [ N ]

0x02

ADD

Add top two values

[ A, B ] -> [ A+B ]

0x03

SUB

Subtract top two values

[ A, B ] -> [ A-B ]

0x04

MUL

Multiply top two values

[ A, B ] -> [ A*B ]

0x05

DIV

Divide top two values

[ A, B ] -> [ A/B ]

0x08

STORE

Save top value to memory

[ Val ] -> [ ]

0x09

LOAD

Load variable from memory

[ ] -> [ Val ]

<div align="center">

Star this Repo ğŸŒŸ if you find it interesting!

Developed with â¤ï¸ using C++ and Python.

</div>